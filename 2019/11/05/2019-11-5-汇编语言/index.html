<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>汇编语言 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">jie-sh&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">jie-sh&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">汇编语言</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">jie-sh</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 5, 2019&nbsp;&nbsp;10:17:36</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p> [toc] </p>
<h1 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h1><ol>
<li><p>通用寄存器：</p>
<ul>
<li>8位：AH，AL，CH，CL，DH，DL，BH，BL</li>
<li>16位：AX，CX，DX，BX，SP，BP，SI，DI</li>
<li>32位：EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI</li>
</ul>
</li>
<li><p>指令指针寄存器：EIP</p>
</li>
<li><p>标志寄存器：eflags</p>
<ul>
<li><p>状态标志位：</p>
<ul>
<li>进位标志 CF：结果的最高位进位则置1</li>
<li>溢出标志 OF：次高位的进位与 CF 异或运算的值就是 OF 的值</li>
<li>符号标志 SF：取结果的最高位作为 SF 的值</li>
<li>零标志 ZF：结果为0则置1</li>
<li>辅助进位标志 AF</li>
<li>奇偶标志 DF</li>
</ul>
</li>
<li><p>控制标志位：</p>
<ul>
<li>方向标志 DF：控制串操作的地址是递增还是递减</li>
<li>中断允许标志 IF</li>
<li>陷阱标志 TF</li>
</ul>
</li>
</ul>
</li>
<li><p>内存管理模式</p>
<ul>
<li><p>16位：<strong>分段机制</strong></p>
<ul>
<li>访问内存时使用逻辑地址，物理地址的计算方式：<code>段基地址 * 16 + 段内偏移</code></li>
<li>访问不同的内存时，会使用不同的段寄存器来提供段基地址<ul>
<li><code>mov ax,[1000h]</code>：默认使用 <code>DS</code> 作为段寄存器</li>
<li><code>mov ax,[bp]</code>：含有 <code>BP</code> 或 <code>SP</code> 的栈底栈顶指针寄存器时，使用 <code>SS</code> 作为默认的段寄存器</li>
<li><code>mov ax,[bx]</code>：默认使用 <code>DS</code> 作为段寄存器</li>
<li>若默认的段寄存器是 <code>DS</code>，那么这个寄存器可以被修改，如 <code>mov ax, ss:[1000h]</code></li>
<li>访问内存时，[ ] 内寄存器的组合是有限的，只能使用 <code>BP</code>，<code>BX</code>，<code>SI</code>，<code>DI</code> 寄存器</li>
</ul>
</li>
</ul>
</li>
<li><p>32位：<strong>保护模式机制</strong></p>
<ul>
<li>段寄存器中保存有段选择子</li>
<li>仍然使用分段机制的方式计算地址：<code>段基地址 * 16 + 段内偏移</code>，但所有的段基地址都是0，故32位的内存管理模式也称为<strong>平坦模式</strong></li>
<li>使用内存操作数时，在  [ ] 内可以使用多种寄存器的组合</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="指令基础"><a href="#指令基础" class="headerlink" title="指令基础"></a>指令基础</h1><ol>
<li><p>指令的组成：操作码（助记符），操作数</p>
<p>其中操作数只有三种类型：寄存器，立即数和内存操作数</p>
</li>
<li><p>指令原型说明符（用于说明指令的操作数可以是什么类型）：</p>
<ul>
<li><p><code>imm</code> ：立即数</p>
</li>
<li><p><code>reg</code>：寄存器</p>
</li>
<li><p><code>seg</code> ：段寄存器</p>
</li>
<li><p><code>mem</code>：内存操作数</p>
</li>
<li><p>大小说明符（决定指令操作数的大小）</p>
<ul>
<li><p>8 - 1字节：</p>
<p><code>reg8</code> 表示只能接受大小是8位的寄存器，如：AH，BH，CL等</p>
<p><code>mem8</code> 表示只能接受大小是8位的内存操作数，如：<code>byte ptr [1000h]</code></p>
</li>
<li><p>16 - 字操作数</p>
</li>
<li><p>32 - 双字操作数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指令的两个操作数一般不能同时都是内存操作数</p>
</li>
<li><p>算术运算指令：</p>
<ul>
<li>加：add</li>
<li>减：sub</li>
<li>乘：mul / imul（有符号乘法指令）</li>
<li>除：div / idiv</li>
<li>自增：inc</li>
<li>自减：dec</li>
</ul>
</li>
<li><p>位运算</p>
<ul>
<li>按位与：and</li>
<li>按位或：or</li>
<li>按位异或：xor</li>
<li>按位取反：not</li>
<li>左移：shl</li>
<li>右移：shr</li>
</ul>
</li>
<li><p>数据传送指令</p>
<ul>
<li>赋值：mov</li>
<li>取地址：lea</li>
<li>交换两个操作数：xchg</li>
<li>数据入栈：push</li>
<li>数据出栈：pop</li>
<li>标志寄存器入栈：pushf</li>
<li>将栈顶值给标志寄存器：popf</li>
<li>将所有寄存器入栈：pushad（顺序：eax，ecx，edx，ebx，esp，ebp，esi，edi）</li>
<li>将栈中数值给所有通用寄存器：popad（顺序与入栈顺序相反）</li>
</ul>
</li>
</ol>
<h1 id="32位寻址模式"><a href="#32位寻址模式" class="headerlink" title="32位寻址模式"></a>32位寻址模式</h1><p>用于确定指令中使用什么操作数</p>
<ol>
<li>立即数寻址</li>
<li>寄存器寻址</li>
<li>存储器寻址<ol>
<li>直接寻址</li>
<li>寄存器间接寻址</li>
<li>寄存器相对寻址</li>
<li>基址变址寻址</li>
<li>相对基址变址寻址</li>
<li>带比例因子寻址</li>
<li>带比例因子相对基址变址寻址</li>
</ol>
</li>
</ol>
<h1 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h1><ol>
<li><p>重复前缀：rep / repe / repne</p>
<p>默认操作数：ecx 保存重复的次数</p>
<p>repe / repne 有一个附加条件：ZF 标志位的值也会影响指令是否继续重复</p>
</li>
<li><p>串移动指令（相当于 memcpy）：movs</p>
</li>
<li><p>串存入指令（相当于 memset）：stos</p>
<p>默认操作数：edi，al/ax/eax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004582FD    B0 32           MOV AL,0x32                    ;串填充的内容0x32(&apos;2&apos;)</span><br><span class="line">004582FF    8D3D 00904500   LEA EDI,DWORD PTR DS:[0x459000];串填充的目的地址</span><br><span class="line">00458305    B9 10000000     MOV ECX,0x10                   ;循环次数</span><br><span class="line">0045830A    FC              CLD                            ;将方向标志置0，递增              </span><br><span class="line">0045830B    F3:AA           REP STOS BYTE PTR ES:[EDI]</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C14622%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572935965242.png" alt="1572935965242"></p>
</li>
<li><p>串取出指令：lods</p>
<p>默认操作数：esi，al/ax/eax</p>
<p>将 esi 指向的内存取出存入 al/ax/eax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">004582FD    8D35 00904500   LEA ESI,DWORD PTR DS:[0x459000];数组的起始地址</span><br><span class="line">00458303    B9 10000000     MOV ECX,0x10                            </span><br><span class="line">00458308    33C0            XOR EAX,EAX</span><br><span class="line">0045830A    33D2            XOR EDX,EDX               ;将eax,edx清空                </span><br><span class="line">0045830C    AC              LODS BYTE PTR DS:[ESI]</span><br><span class="line">0045830D    90              NOP</span><br><span class="line">0045830E    03D0            ADD EDX,EAX</span><br><span class="line">00458310  ^ E2 FA           LOOPD SHORT CKme.0045830C ;跳转到0x0045830C处，并将ecx减1</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C14622%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572940498963.png" alt="1572940498963"></p>
</li>
<li><p>串比较指令（相当于 memcmp）：cmps</p>
<p>默认操作数：edi，esi</p>
<p>取出 esi 和 edi 的值进行比较，根据比较结果设置状态标志位，但不保存比较结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">004582FD    8D35 10904500   LEA ESI,DWORD PTR DS:[0x459010];比较的源地址</span><br><span class="line">00458303    8D3D 20904500   LEA EDI,DWORD PTR DS:[0x459020];比较的目的地址     </span><br><span class="line">00458309    B9 10000000     MOV ECX,0x10</span><br><span class="line">0045830E    FC              CLD</span><br><span class="line">0045830F    F3:A6           REPE CMPS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI];循环比较，直到ecx为0或ZF为0时结束</span><br><span class="line">00458311    74 1F           JE SHORT CKme.00458332;若相等则跳转</span><br><span class="line">00458313    BB 01000000     MOV EBX,0x1;否则将bx置1</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C14622%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1572941081723.png" alt="1572941081723"></p>
</li>
</ol>
<p>   无符号数的大小比较通过进位标志 CF 来判断，若 CF=0，则前者大于后者，否则后者大于前者，再结合 ZF 判断是否相等</p>
<p>   有符号数的比较：</p>
<table>
<thead>
<tr>
<th>结果</th>
<th>标记位</th>
</tr>
</thead>
<tbody><tr>
<td>大于</td>
<td>OF == SF 且 ZF == 0</td>
</tr>
<tr>
<td>小于</td>
<td>OF != SF</td>
</tr>
<tr>
<td>大于等于</td>
<td>OF == SF</td>
</tr>
<tr>
<td>小于等于</td>
<td>OF != SF 且 ZF == 1</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>repe scas：扫描与指定字符不同的字符串</p>
<p>temp &lt;— AX - SRC</p>
<p>FFFF FFFF - 5 = FFFF FFFA 取反得 0000 0005</p>
</li>
</ol>
<p>​        </p>
<h1 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h1><ol>
<li><p>loop 循环指定次数</p>
<p>默认操作：ecx 保存循环次数，每循环一次，ecx 就减1，直到减为0就结束循环</p>
</li>
<li><p>jmp 无条件转移指令</p>
<p>间接修改 eip，使程序转移到其他位置执行代码</p>
</li>
<li><p>函数调用指令：call</p>
<p>调用前先将返回地址（call 指令的下一条指令）入栈</p>
<p>跳转到目标地址</p>
</li>
<li><p>函数返回指令：ret</p>
<p>调用时，将栈顶值作为返回值弹出到 eip</p>
<p>eip 指向哪里，就在哪个地方继续执行代码</p>
<p><code>ret 立即数</code>，将栈顶值弹出到 eip，然后 esp 加上立即数</p>
</li>
</ol>
<h1 id="JCC-指令（条件跳转指令）"><a href="#JCC-指令（条件跳转指令）" class="headerlink" title="JCC 指令（条件跳转指令）"></a>JCC 指令（条件跳转指令）</h1><ol>
<li>无符号跳转指令</li>
<li>有符号跳转指令</li>
<li>其他指令</li>
</ol>
<h1 id="程序基础"><a href="#程序基础" class="headerlink" title="程序基础"></a>程序基础</h1><ul>
<li>三大结构<ul>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
</ul>
</li>
<li>函数</li>
</ul>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><ol>
<li><p>if … else if … else</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nDay = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nDay);</span><br><span class="line"><span class="keyword">if</span>(nDay == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"周一"</span>);</span><br><span class="line"><span class="keyword">if</span>(nDay == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"周二"</span>);</span><br><span class="line"><span class="keyword">if</span>(nDay == <span class="number">13</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"周三"</span>);</span><br></pre></td></tr></table></figure>

<p>汇编版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">fun proc</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp, esp</span><br><span class="line">	;scanf(&quot;%d&quot;, &amp;nDay)</span><br><span class="line">	sub esp, 4 ;为局部变量分配栈空间，ebp-4为nDay的位置</span><br><span class="line">	lea eax, [ebp-4] ;eax=&amp;nDay</span><br><span class="line">	push eax</span><br><span class="line">	push &quot;%d&quot;</span><br><span class="line">	call crt_scanf </span><br><span class="line">	</span><br><span class="line">	cmp dword ptr [ebp-4], 1</span><br><span class="line">	jne _IF_1</span><br><span class="line">	;if(nDay == 1)</span><br><span class="line">	push &quot;周一&quot;</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 4</span><br><span class="line">	jmp _ENDIF</span><br><span class="line">	</span><br><span class="line">_IF_1:</span><br><span class="line">	cmp dword ptr [ebp-4], 2</span><br><span class="line">	jne _IF_2</span><br><span class="line">	;if(nDay == 2)</span><br><span class="line">	push &quot;周二&quot;</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 4</span><br><span class="line">	jmp _ENDIF</span><br><span class="line">	</span><br><span class="line">_IF_2：</span><br><span class="line">	cmp dword ptr [ebp-4], 3</span><br><span class="line">	jne _IF_3</span><br><span class="line">	;if(nDay == 3)</span><br><span class="line">	push &quot;周三&quot;</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 4</span><br><span class="line">	jmp _ENDIF</span><br><span class="line">	</span><br><span class="line">_IF_3:</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">_ENDIF:</span><br><span class="line">	mov esp, ebp</span><br><span class="line">	pop ebp	</span><br><span class="line">fun endp</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C 语言中使用 {} 来分隔每个语句块</p>
</li>
<li><p>汇编指令是自上至下逐条执行，没有跳转指令是不会跑到其他位置执行代码</p>
</li>
<li><p>汇编中构建一个语句块的方式是：</p>
<p>在语句块前加入一条条件跳转指令</p>
<p>在语句块后加入一条无条件跳转指令</p>
</li>
</ul>
</li>
<li><p>switch … case</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nDay = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nDay);</span><br><span class="line"><span class="keyword">switch</span>(nDay)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"周一"</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"周二"</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"周三"</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编版本：</p>
<ol>
<li>和 if 语句的版本一样</li>
<li>使用跳转表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">.const</span><br><span class="line">	pszD db&apos;%d&apos;, 0</span><br><span class="line">	pszTips1 db&apos;周一&apos;, 0dh, 0ah, 0</span><br><span class="line">	pszTips2 db&apos;周二&apos;, 0dh, 0ah, 0</span><br><span class="line">	pszTips3 db&apos;周三&apos;, 0dh, 0ah, 0</span><br><span class="line">	</span><br><span class="line">.code</span><br><span class="line">fun proc</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp, esp</span><br><span class="line">	</span><br><span class="line">	sub esp, 4 ;为局部变量分配栈空间</span><br><span class="line">	;scanf(&quot;%d&quot;, &amp;nDay)</span><br><span class="line">	lea eax, [ebp-4] ;eax=&amp;nDay</span><br><span class="line">	push eax</span><br><span class="line">	push offset pszD</span><br><span class="line">	call crt_scanf</span><br><span class="line">	;若输入值大于3则函数结束</span><br><span class="line">	cmp dword ptr [ebp-4], 3</span><br><span class="line">	jg _ENDIF</span><br><span class="line">	</span><br><span class="line">	mov eax, [ebp-4]</span><br><span class="line">	dec eax ;nDay = nDay-1</span><br><span class="line">	;jmptab dd _IF_0, _IF_1, _IF_2</span><br><span class="line">	;通过使用输入值作为下标，从数组中索引出一个地址，再跳转到此地址</span><br><span class="line">	jmp dword ptr [jmptab+eax*4]</span><br><span class="line">	;在代码中定义数据：dword jmptab[3] = &#123; _IF_0, _IF_1, _IF_2 &#125;</span><br><span class="line">	;编译后 _IF_0标签就会编译成代码的地址</span><br><span class="line">	jmptab dd _IF_0, _IF_1, _IF_2</span><br><span class="line">	</span><br><span class="line">_IF_0:</span><br><span class="line">	;if(nDay == 1)</span><br><span class="line">	push offset pszTips1</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 4</span><br><span class="line">	jmp _ENDIF</span><br><span class="line">_IF_1:</span><br><span class="line">	push offset pszTips2</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 4</span><br><span class="line">	jmp _ENDIF</span><br><span class="line">_IF_2:</span><br><span class="line">	push offset pszTips3</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 4</span><br><span class="line">	jmp _ENDIF</span><br><span class="line">	</span><br><span class="line">_ENDIF:	</span><br><span class="line">	mov esp, ebp</span><br><span class="line">	pop ebp</span><br><span class="line">	ret</span><br><span class="line">fun endp</span><br><span class="line">main:</span><br><span class="line">	call fun</span><br><span class="line">	ret</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><ol>
<li><p>while</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编版本：通过条件跳转指令来模拟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">.const</span><br><span class="line">	pszD db&apos;%d&apos;, 0dh, 0ah, 0</span><br><span class="line">		</span><br><span class="line">.code</span><br><span class="line">fun proc	</span><br><span class="line">	;由于没有参数，故可以不需开辟栈帧，将局部变量保存在ebx，不能存在eax，因为printf函数也会用到eax，会改变其值，使程序一直循环，eax是易失性寄存器</span><br><span class="line">	sub esp, 4</span><br><span class="line">	mov dword ptr [esp], 0 ;i = 0</span><br><span class="line">	mov ebx, [esp]</span><br><span class="line">	;while(i &lt; 100)</span><br><span class="line">_WHILE:</span><br><span class="line">	cmp ebx, 100</span><br><span class="line">	jge _END ;若比较结果大于等于0，即i大于等于100就跳出循环</span><br><span class="line">	push ebx</span><br><span class="line">	push offset pszD</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 8</span><br><span class="line">	;++i</span><br><span class="line">	inc ebx</span><br><span class="line">	jmp _WHILE	</span><br><span class="line">_END:	</span><br><span class="line">	add esp, 4</span><br><span class="line">	ret</span><br><span class="line">fun endp</span><br><span class="line">main:</span><br><span class="line">	call fun</span><br><span class="line">	ret</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>do … while</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    ++i;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">.const</span><br><span class="line">	pszD db&apos;%d&apos;, 0dh, 0ah, 0</span><br><span class="line">		</span><br><span class="line">.code</span><br><span class="line">fun proc	</span><br><span class="line">	sub esp, 4</span><br><span class="line">	mov dword ptr [esp], 0 ;i = 0</span><br><span class="line">	mov ebx, [esp]</span><br><span class="line">_DOWHILE:</span><br><span class="line">	push ebx</span><br><span class="line">	push offset pszD</span><br><span class="line">	call crt_printf</span><br><span class="line">	add esp, 8</span><br><span class="line">	inc ebx</span><br><span class="line">	cmp ebx, 100</span><br><span class="line">	jge _END</span><br><span class="line">	jl _DOWHILE</span><br><span class="line">_END:	</span><br><span class="line">	add esp, 4</span><br><span class="line">	ret</span><br><span class="line">fun endp</span><br><span class="line">main:</span><br><span class="line">	call fun</span><br><span class="line">	ret</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 循环结构和 while 循环一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><table>
<thead>
<tr>
<th>调用约定</th>
<th>传参方式</th>
<th>平衡栈方式</th>
</tr>
</thead>
<tbody><tr>
<td>cdecl（C 调用约定）</td>
<td>从右往左</td>
<td>函数外平衡（调用者平衡），add esp, xx</td>
</tr>
<tr>
<td>stdcall（标准调用约定）</td>
<td>从右往左</td>
<td>函数内平衡（被调者平衡），ret xx</td>
</tr>
<tr>
<td>fastcall（快速调用约定）</td>
<td>前2个参数依次使用 ecx，edx 来传递，后续参数通过栈传递（从右往左依次入栈）</td>
<td>函数内平衡（被调者平衡），ret xx</td>
</tr>
<tr>
<td>thiscall（对象调用约定）</td>
<td>通过 ecx 来保存 this 指针，参数从右往左依次入栈</td>
<td>函数内平衡（被调者平衡），ret xx</td>
</tr>
</tbody></table>
<p>调用约定制约在代码中传参的方式和平衡栈的方式</p>
<p>在汇编中调用函数前需要搞清楚这个函数使用什么调用约定，否则参数就无法正确传递</p>
<p>总结：</p>
<ol>
<li><p>参数是通过栈来传递的，有时是直接 <code>push</code> 到栈中，有时也可先 <code>sub esp</code> 拉高栈顶，再使用 <code>mov [esp]</code> 的方式将实参赋值到栈中，总之能将实参放入栈中的合适位置就可以、</p>
<p>esp 栈顶高地址的位置一般都是被使用过的，不应随意修改，而 esp 低地址的位置一般未被使用，可以用来保存新数据</p>
</li>
<li><p>函数调用完毕后需要平衡栈</p>
</li>
<li><p>函数返回值一般约定使用 eax 来保存</p>
</li>
</ol>
<h2 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h2><ol>
<li><p>实参通过栈传递后，在函数内部的定位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;定义一个函数</span><br><span class="line">;void fun(int n1, int n2, int n3)</span><br><span class="line">fun proc</span><br><span class="line">	push ebp;要使用ebp保存当前栈顶的值，因此需要先将寄存器的值备份起来</span><br><span class="line">	mov ebp, esp;将原栈顶位置保存到ebp中，这样即使栈顶发生浮动也不会影响通过ebp+固定偏移的方式去定位到栈内形参</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	;离开函数前需要恢复在函数内部使用的寄存器的值</span><br><span class="line">	;恢复esp和ebp的值</span><br><span class="line">	mov esp,ebp;在函数开头，将esp的值保存到ebp中，而ebp在整个函数中是不会被修改的，故esp的值就可使用ebp来恢复</span><br><span class="line">	pop ebp;在函数开头，ebp的值保存在栈中，因此可直接pop出ebp原来的值</span><br><span class="line">	ret</span><br><span class="line">fun endp</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C14622%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573028086214.png" alt="1573028086214"></p>
</li>
</ol>
<h2 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h2><ol>
<li>在打开栈帧后，需要给局部变量开辟栈空间<ol>
<li>通过 <code>sub esp</code>，所有局部变量的字节数</li>
<li>esp 的低地址位置一般未被使用，可以用来保存新数据，故没将数据往上抬，栈空间内的数据就可能被 push 或 call 指令的操作覆盖</li>
</ol>
</li>
<li>通过 <code>ebp-4</code> 得到第一个局部变量的偏移</li>
</ol>
<h2 id="易失性寄存器"><a href="#易失性寄存器" class="headerlink" title="易失性寄存器"></a>易失性寄存器</h2><p>一般进入函数后，函数内部使用寄存器前需要备份寄存器的值，离开函数时，会将寄存器的值恢复，但有些寄存器不会恢复，这些不会恢复的寄存器称为易失性寄存器</p>
<p>windows 的 API 函数的易失性寄存器是 eax</p>
<p>C 运行时库函数（crt_xxx 系列函数）的易失性寄存器是 eax，ecx，edx，ebx</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line"></span><br><span class="line">MYSTRUCT struct ;定义一个结构体</span><br><span class="line">	nNum dd ?</span><br><span class="line">	szBuff db 100 dup(?)</span><br><span class="line">MYSTRUCT ends</span><br><span class="line"></span><br><span class="line">PERSON struct ;定义一个结构体</span><br><span class="line">	age dd ?</span><br><span class="line">	sex db ?</span><br><span class="line">	szName db 100 dup(?)</span><br><span class="line">PERSON ends</span><br><span class="line">.const</span><br><span class="line">	pszHello db&apos;Hello&apos;, 0</span><br><span class="line">	pszHello15PB db&apos;Hello 15PB&apos;, 0</span><br><span class="line">.code</span><br><span class="line">fun proc</span><br><span class="line">	;定义一个结构体局部变量</span><br><span class="line">	;PERSON personobj</span><br><span class="line">	;MYSTRUCT myobj</span><br><span class="line">	sub esp, sizeof(PERSON)+sizeof(MYSTRUCT)</span><br><span class="line">	;PERSON --&gt; esp</span><br><span class="line">	;MYSTRUCT --&gt; esp+sizeof(PERSON)</span><br><span class="line">	</span><br><span class="line">	mov ecx, esp ;ecx存PERSON的首地址</span><br><span class="line">	;personobj.age = 18</span><br><span class="line">	mov dword ptr [ecx + PERSON.age], 18</span><br><span class="line">	;personobj.sex = &apos;M&apos;</span><br><span class="line">	mov byte ptr [ecx + PERSON.sex], &apos;M&apos;</span><br><span class="line">	;personobj.szName = &quot;Hello&quot;</span><br><span class="line">	;strcpy(personobj.szName, &quot;Hello&quot;)</span><br><span class="line">	push offset pszHello</span><br><span class="line">	lea eax, [ecx + PERSON.szName]</span><br><span class="line">	push eax</span><br><span class="line">	call crt_strcpy</span><br><span class="line">	add esp, 8</span><br><span class="line">	</span><br><span class="line">	lea esi, [esp + sizeof(PERSON)] ;esi存MYSTRUCT的首地址</span><br><span class="line">	;myobj.nNum = 20</span><br><span class="line">	mov dword ptr [esi + MYSTRUCT.nNum], 20</span><br><span class="line">	;myobj.szBuff = &quot;Hello 15PB&quot;</span><br><span class="line">	;strcpy(myobj.szBuff, &quot;Hello 15PB&quot;)</span><br><span class="line">	push offset pszHello15PB</span><br><span class="line">	lea eax, [esi + MYSTRUCT.szBuff]</span><br><span class="line">	push eax</span><br><span class="line">	call crt_strcpy</span><br><span class="line">	add esp, 8</span><br><span class="line">	</span><br><span class="line">	ret</span><br><span class="line">fun endp</span><br><span class="line">main:</span><br><span class="line">	call fun</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2019/10/28/2019-10-28-进程与线程/">进程与线程</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© jie-sh | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
